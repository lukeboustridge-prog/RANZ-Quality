---
phase: 11-personal-settings
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/notifications.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Notification system checks user preferences before sending email notifications"
    - "Notification system checks user preferences before sending SMS notifications"
    - "Critical SMS alerts bypass user preferences and always send"
    - "Organization preferences are checked before user preferences (two-tier hierarchy)"
  artifacts:
    - path: "src/lib/notifications.ts"
      provides: "Preference-aware notification sending"
      contains: "shouldSendToUser"
  key_links:
    - from: "src/lib/notifications.ts"
      to: "NotificationPreference"
      via: "db.notificationPreference.findUnique"
      pattern: "notificationPreference\\.findUnique"
    - from: "src/lib/notifications.ts"
      to: "OrganizationNotificationPreference"
      via: "db.organizationNotificationPreference.findUnique"
      pattern: "organizationNotificationPreference\\.findUnique"
---

<objective>
Close the verification gap where user notification preferences are not respected by the notification system.

Purpose: Users set preferences via UI but notifications send regardless of opt-out settings. This gap closure implements the two-tier preference hierarchy so the notification system honors both organization and user preferences.

Output: Modified `src/lib/notifications.ts` that checks preferences before sending email/SMS notifications.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-personal-settings/11-VERIFICATION.md
@.planning/phases/11-personal-settings/11-RESEARCH.md

Key insight from 11-RESEARCH.md - Notification Preference Hierarchy:
```
Notification Decision Tree:
1. Check if notification type is critical/security-related
   → YES: Send regardless of preferences (security trumps all)
   → NO: Continue to step 2

2. Check organization notification preferences (Phase 9)
   → If org has disabled this notification type: STOP (don't send)
   → If org allows: Continue to step 3

3. Check user notification preferences (Phase 11)
   → If user has opted out: STOP (don't send)
   → If user allows: Continue to step 4

4. Check channel availability
   → Email: User has verified email? Send
   → SMS: User has valid phone number? Send
   → In-app: Always available

Final decision: Send notification via allowed channels
```

Database models:
- NotificationPreference: userId, emailEnabled, emailInsurance, emailAudit, emailCompliance, emailNewsletter, smsEnabled, smsInsurance, smsAudit, smsCritical
- OrganizationNotificationPreference: organizationId, emailEnabled, emailInsuranceAlerts, emailAuditAlerts, emailComplianceAlerts, emailSystemAlerts, smsEnabled, smsInsuranceAlerts, smsAuditAlerts, smsCriticalAlerts

NotificationType enum values:
- INSURANCE_EXPIRY, INSURANCE_EXPIRED → maps to emailInsurance/smsInsurance preference
- AUDIT_SCHEDULED, AUDIT_REMINDER, AUDIT_COMPLETED → maps to emailAudit/smsAudit preference
- COMPLIANCE_ALERT → maps to emailCompliance preference
- LBP_EXPIRY, LBP_STATUS_CHANGE → critical, always send
- CAPA_DUE, CAPA_OVERDUE → maps to emailCompliance preference
- DOCUMENT_REVIEW_DUE → maps to emailCompliance preference
- TIER_CHANGE → system notification
- WELCOME, SYSTEM → system notification
- TESTIMONIAL_REQUEST, TESTIMONIAL_RECEIVED → maps to emailNewsletter preference (optional marketing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add preference checking helper functions to notifications.ts</name>
  <files>src/lib/notifications.ts</files>
  <action>
Add helper functions at the top of the file (after the resend initialization) to check notification preferences:

1. Create a type mapping NotificationType to preference fields:
```typescript
// Map notification types to user preference fields
const NOTIFICATION_TYPE_TO_EMAIL_PREF: Record<NotificationType, keyof NotificationPreference | null> = {
  INSURANCE_EXPIRY: "emailInsurance",
  INSURANCE_EXPIRED: "emailInsurance",
  LBP_EXPIRY: null,           // Critical - always send
  LBP_STATUS_CHANGE: null,    // Critical - always send
  AUDIT_SCHEDULED: "emailAudit",
  AUDIT_REMINDER: "emailAudit",
  AUDIT_COMPLETED: "emailAudit",
  CAPA_DUE: "emailCompliance",
  CAPA_OVERDUE: "emailCompliance",
  COMPLIANCE_ALERT: "emailCompliance",
  DOCUMENT_REVIEW_DUE: "emailCompliance",
  TESTIMONIAL_REQUEST: "emailNewsletter",
  TESTIMONIAL_RECEIVED: "emailNewsletter",
  TIER_CHANGE: null,          // System - always send
  WELCOME: null,              // System - always send
  SYSTEM: null,               // System - always send
};

const NOTIFICATION_TYPE_TO_SMS_PREF: Record<NotificationType, keyof NotificationPreference | null> = {
  INSURANCE_EXPIRY: "smsInsurance",
  INSURANCE_EXPIRED: "smsInsurance",
  LBP_EXPIRY: "smsCritical",     // Maps to critical but forced on
  LBP_STATUS_CHANGE: "smsCritical", // Maps to critical but forced on
  AUDIT_SCHEDULED: "smsAudit",
  AUDIT_REMINDER: "smsAudit",
  AUDIT_COMPLETED: "smsAudit",
  CAPA_DUE: "smsCritical",       // Urgent CAPA is critical
  CAPA_OVERDUE: "smsCritical",   // Overdue CAPA is critical
  COMPLIANCE_ALERT: "smsCritical", // Compliance alerts are critical
  DOCUMENT_REVIEW_DUE: null,     // No SMS for document review
  TESTIMONIAL_REQUEST: null,     // No SMS for testimonials
  TESTIMONIAL_RECEIVED: null,    // No SMS for testimonials
  TIER_CHANGE: "smsCritical",    // Tier changes are important
  WELCOME: null,                 // No SMS for welcome
  SYSTEM: "smsCritical",         // System alerts are critical
};

// Map notification types to organization preference fields
const NOTIFICATION_TYPE_TO_ORG_EMAIL_PREF: Record<NotificationType, keyof OrganizationNotificationPreference | null> = {
  INSURANCE_EXPIRY: "emailInsuranceAlerts",
  INSURANCE_EXPIRED: "emailInsuranceAlerts",
  LBP_EXPIRY: null,              // Critical - always send
  LBP_STATUS_CHANGE: null,       // Critical - always send
  AUDIT_SCHEDULED: "emailAuditAlerts",
  AUDIT_REMINDER: "emailAuditAlerts",
  AUDIT_COMPLETED: "emailAuditAlerts",
  CAPA_DUE: "emailComplianceAlerts",
  CAPA_OVERDUE: "emailComplianceAlerts",
  COMPLIANCE_ALERT: "emailComplianceAlerts",
  DOCUMENT_REVIEW_DUE: "emailComplianceAlerts",
  TESTIMONIAL_REQUEST: "emailSystemAlerts",
  TESTIMONIAL_RECEIVED: "emailSystemAlerts",
  TIER_CHANGE: "emailSystemAlerts",
  WELCOME: "emailSystemAlerts",
  SYSTEM: "emailSystemAlerts",
};

const NOTIFICATION_TYPE_TO_ORG_SMS_PREF: Record<NotificationType, keyof OrganizationNotificationPreference | null> = {
  INSURANCE_EXPIRY: "smsInsuranceAlerts",
  INSURANCE_EXPIRED: "smsInsuranceAlerts",
  LBP_EXPIRY: "smsCriticalAlerts",
  LBP_STATUS_CHANGE: "smsCriticalAlerts",
  AUDIT_SCHEDULED: "smsAuditAlerts",
  AUDIT_REMINDER: "smsAuditAlerts",
  AUDIT_COMPLETED: "smsAuditAlerts",
  CAPA_DUE: "smsCriticalAlerts",
  CAPA_OVERDUE: "smsCriticalAlerts",
  COMPLIANCE_ALERT: "smsCriticalAlerts",
  DOCUMENT_REVIEW_DUE: null,
  TESTIMONIAL_REQUEST: null,
  TESTIMONIAL_RECEIVED: null,
  TIER_CHANGE: "smsCriticalAlerts",
  WELCOME: null,
  SYSTEM: "smsCriticalAlerts",
};
```

2. Create the shouldSendNotification helper function:
```typescript
import type { NotificationPreference, OrganizationNotificationPreference } from "@prisma/client";

/**
 * Check if a notification should be sent based on two-tier preference hierarchy:
 * 1. Critical notifications (LBP status changes, smsCritical) always send
 * 2. Organization must have the notification type enabled
 * 3. User must have opted in (or not opted out)
 *
 * Returns: { shouldSend: boolean, reason?: string }
 */
async function shouldSendNotification(params: {
  organizationId?: string;
  userId?: string;
  type: NotificationType;
  channel: NotificationChannel;
  priority?: NotificationPriority;
}): Promise<{ shouldSend: boolean; reason?: string }> {
  const { organizationId, userId, type, channel, priority } = params;

  // IN_APP and PUSH notifications always allowed (no opt-out)
  if (channel === "IN_APP" || channel === "PUSH") {
    return { shouldSend: true };
  }

  // CRITICAL priority notifications always send (security trumps preferences)
  if (priority === "CRITICAL") {
    return { shouldSend: true };
  }

  // Check if this notification type is critical (null mapping = always send)
  const emailPrefKey = NOTIFICATION_TYPE_TO_EMAIL_PREF[type];
  const smsPrefKey = NOTIFICATION_TYPE_TO_SMS_PREF[type];

  if (channel === "EMAIL" && emailPrefKey === null) {
    return { shouldSend: true }; // Critical email, always send
  }
  if (channel === "SMS" && smsPrefKey === null) {
    return { shouldSend: true }; // Critical SMS, always send
  }

  // SMS critical (smsCritical) is forced on - always send regardless of user preference
  if (channel === "SMS" && smsPrefKey === "smsCritical") {
    return { shouldSend: true };
  }

  // Step 2: Check organization preferences (if organizationId provided)
  if (organizationId) {
    const orgPrefs = await db.organizationNotificationPreference.findUnique({
      where: { organizationId },
    });

    if (orgPrefs) {
      // Check master channel enable
      if (channel === "EMAIL" && !orgPrefs.emailEnabled) {
        return { shouldSend: false, reason: "Organization has email notifications disabled" };
      }
      if (channel === "SMS" && !orgPrefs.smsEnabled) {
        return { shouldSend: false, reason: "Organization has SMS notifications disabled" };
      }

      // Check specific notification type for org
      const orgEmailPrefKey = NOTIFICATION_TYPE_TO_ORG_EMAIL_PREF[type];
      const orgSmsPrefKey = NOTIFICATION_TYPE_TO_ORG_SMS_PREF[type];

      if (channel === "EMAIL" && orgEmailPrefKey && !orgPrefs[orgEmailPrefKey]) {
        return { shouldSend: false, reason: `Organization has ${type} email notifications disabled` };
      }
      if (channel === "SMS" && orgSmsPrefKey && !orgPrefs[orgSmsPrefKey]) {
        return { shouldSend: false, reason: `Organization has ${type} SMS notifications disabled` };
      }
    }
    // If no org prefs record, default to allowing (org hasn't configured preferences)
  }

  // Step 3: Check user preferences (if userId provided)
  if (userId) {
    const userPrefs = await db.notificationPreference.findUnique({
      where: { userId },
    });

    if (userPrefs) {
      // Check master channel enable
      if (channel === "EMAIL" && !userPrefs.emailEnabled) {
        return { shouldSend: false, reason: "User has email notifications disabled" };
      }
      if (channel === "SMS" && !userPrefs.smsEnabled) {
        return { shouldSend: false, reason: "User has SMS notifications disabled" };
      }

      // Check specific notification type for user
      if (channel === "EMAIL" && emailPrefKey) {
        const prefValue = userPrefs[emailPrefKey as keyof NotificationPreference];
        if (prefValue === false) {
          return { shouldSend: false, reason: `User has opted out of ${type} email notifications` };
        }
      }
      if (channel === "SMS" && smsPrefKey && smsPrefKey !== "smsCritical") {
        const prefValue = userPrefs[smsPrefKey as keyof NotificationPreference];
        if (prefValue === false) {
          return { shouldSend: false, reason: `User has opted out of ${type} SMS notifications` };
        }
      }
    }
    // If no user prefs record, default to allowing (user hasn't configured preferences)
  }

  return { shouldSend: true };
}
```

Import NotificationPreference and OrganizationNotificationPreference types from Prisma client at the top of the file.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd "RANZ Quality Program" && npx tsc --noEmit src/lib/notifications.ts
```
  </verify>
  <done>Helper functions exist for preference checking with correct type mappings for all NotificationType values</done>
</task>

<task type="auto">
  <name>Task 2: Integrate preference checking into createNotification function</name>
  <files>src/lib/notifications.ts</files>
  <action>
Modify the `createNotification` function to check preferences before creating the notification record:

1. At the beginning of createNotification (after destructuring params), add preference check:
```typescript
// Check if notification should be sent based on preferences
const prefCheck = await shouldSendNotification({
  organizationId,
  userId,
  type,
  channel,
  priority,
});

if (!prefCheck.shouldSend) {
  // Log why notification was skipped (useful for debugging)
  console.log(`[Notification] Skipped ${type} via ${channel}: ${prefCheck.reason}`);

  // Return a "skipped" result without creating a record
  return {
    success: true,
    notificationId: "", // Empty ID indicates skipped
    skipped: true,
    reason: prefCheck.reason,
  };
}
```

2. Update the SendResult interface to include optional skip fields:
```typescript
interface SendResult {
  success: boolean;
  notificationId: string;
  externalId?: string;
  error?: string;
  skipped?: boolean;    // NEW: true if notification was skipped due to preferences
  reason?: string;      // NEW: reason for skip
}
```

This ensures:
- Preference check happens BEFORE database record creation
- Skipped notifications don't clutter the database
- Callers can distinguish between sent and skipped notifications
- Logging provides visibility into preference-based filtering
  </action>
  <verify>
1. TypeScript compiles:
```bash
cd "RANZ Quality Program" && npx tsc --noEmit src/lib/notifications.ts
```

2. Verify the preference check is in createNotification by searching for shouldSendNotification call:
```bash
grep -n "shouldSendNotification" "RANZ Quality Program/src/lib/notifications.ts"
```
  </verify>
  <done>createNotification checks preferences before creating notification records, skipping notifications when user/org has opted out</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation:**
```bash
cd "RANZ Quality Program" && npx tsc --noEmit
```

2. **Verify preference mapping exists:**
```bash
grep -n "NOTIFICATION_TYPE_TO_EMAIL_PREF" "RANZ Quality Program/src/lib/notifications.ts"
```

3. **Verify shouldSendNotification function exists:**
```bash
grep -n "async function shouldSendNotification" "RANZ Quality Program/src/lib/notifications.ts"
```

4. **Verify createNotification calls shouldSendNotification:**
```bash
grep -A 5 "shouldSendNotification" "RANZ Quality Program/src/lib/notifications.ts" | head -20
```

5. **Verify critical notifications bypass preferences:**
- LBP_EXPIRY, LBP_STATUS_CHANGE mapped to null (always send)
- smsCritical mapped notifications always send
- CRITICAL priority always sends
</verification>

<success_criteria>
1. TypeScript compiles without errors
2. `shouldSendNotification` function exists and handles two-tier preference hierarchy
3. `createNotification` calls `shouldSendNotification` before creating notification records
4. Critical notifications (LBP changes, smsCritical, CRITICAL priority) bypass preference checks
5. Skipped notifications return success=true with skipped=true and reason
6. Console logging indicates when notifications are skipped and why
</success_criteria>

<output>
After completion, create `.planning/phases/11-personal-settings/11-03-SUMMARY.md`
</output>
