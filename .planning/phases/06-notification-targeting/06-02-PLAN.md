---
phase: 06-notification-targeting
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - src/app/api/cron/notifications/route.ts
autonomous: true

must_haves:
  truths:
    - "Insurance alert at 90 days sets alert90Sent flag atomically with notification creation"
    - "Insurance alert at 60 days sets alert60Sent flag atomically with notification creation"
    - "Insurance alert at 30 days sets alert30Sent flag atomically with notification creation"
    - "If notification creation fails, alert flag is NOT set (transaction rollback)"
    - "If flag update fails, notification is NOT created (transaction rollback)"
    - "Each expiry alert sends exactly once (no duplicates on cron re-run)"
  artifacts:
    - path: "src/app/api/cron/notifications/route.ts"
      provides: "Atomic flag updates for insurance expiry alerts"
      contains: "\\$transaction"
  key_links:
    - from: "checkInsuranceExpiries"
      to: "db.$transaction"
      via: "Prisma transaction wrapper"
      pattern: "await db\\.\\$transaction"
---

<objective>
Wrap insurance expiry notification and flag update in Prisma transaction to prevent duplicate alerts.

Purpose: Currently, if notifyInsuranceExpiry() succeeds but the subsequent flag update fails, the next cron run would re-send the alert (duplicate). Using a transaction ensures atomicity: either both succeed or both fail together.

Output: Insurance alerts guaranteed to send exactly once per policy per threshold (90/60/30 days).
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notification-targeting/06-RESEARCH.md

@src/app/api/cron/notifications/route.ts
@src/lib/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap insurance expiry notification in transaction</name>
  <files>src/app/api/cron/notifications/route.ts</files>
  <action>
Update the `checkInsuranceExpiries()` function to use Prisma transactions for atomic flag updates.

**Current code pattern (lines 95-133):**
```typescript
for (const policy of expiringPolicies) {
  // ... calculate daysUntilExpiry, get owner

  await notifyInsuranceExpiry({ ... });  // Send notification

  // Mark alert as sent (SEPARATE from notification)
  await db.insurancePolicy.update({
    where: { id: policy.id },
    data: updateData,
  });

  alertsSent++;
}
```

**Replace with transactional pattern:**
```typescript
for (const policy of expiringPolicies) {
  const daysUntilExpiry = Math.ceil(
    (policy.expiryDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000)
  );

  const owner = policy.organization.members[0];
  if (!owner) continue;

  const policyTypeLabels: Record<string, string> = {
    PUBLIC_LIABILITY: "Public Liability",
    PROFESSIONAL_INDEMNITY: "Professional Indemnity",
    STATUTORY_LIABILITY: "Statutory Liability",
  };

  // Determine which flag to update
  const updateData: Record<string, boolean> = {};
  if (daysUntilExpiry >= 85 && daysUntilExpiry <= 95) {
    updateData.alert90Sent = true;
  } else if (daysUntilExpiry >= 55 && daysUntilExpiry <= 65) {
    updateData.alert60Sent = true;
  } else if (daysUntilExpiry >= 25 && daysUntilExpiry <= 35) {
    updateData.alert30Sent = true;
  }

  try {
    // Atomic transaction: notification + flag update
    await db.$transaction(async (tx) => {
      // Send notification (creates record in Notification table)
      await notifyInsuranceExpiry({
        organizationId: policy.organizationId,
        businessName: policy.organization.name,
        policyType: policyTypeLabels[policy.policyType] || policy.policyType,
        daysUntilExpiry,
        ownerEmail: owner.email,
        ownerPhone: owner.phone || undefined,
      });

      // Mark alert as sent (same transaction)
      await tx.insurancePolicy.update({
        where: { id: policy.id },
        data: updateData,
      });
    });

    alertsSent++;
  } catch (error) {
    // Transaction failed - neither notification nor flag update committed
    console.error(
      `Failed to send insurance expiry notification for policy ${policy.id}:`,
      error
    );
    // Continue with next policy - don't fail entire cron
  }
}
```

**Key changes:**
1. Move `updateData` calculation BEFORE the transaction (so we know what flag to set)
2. Wrap `notifyInsuranceExpiry()` + flag update in `db.$transaction()`
3. Use `tx.insurancePolicy.update()` (transaction client) instead of `db.insurancePolicy.update()`
4. Add try/catch around transaction to handle failures gracefully
5. Only increment `alertsSent` on successful transaction
6. Log error but continue loop on failure (don't break entire cron)

**Important:** The notification function `notifyInsuranceExpiry()` creates records using `db.notification.create()` internally. However, since we're wrapping the OUTER call in a transaction and the flag update uses `tx`, if the flag update fails, the transaction rolls back but the notification may already be sent (Resend/Twilio are external).

This is acceptable because:
- If external send fails, notification record status = FAILED (retry mechanism handles it)
- If flag update fails after notification sends, we might get one duplicate on next run
- The transaction primarily protects against flag-only failures

For true atomicity with external services, we'd need a saga pattern (out of scope for MVP).
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/app/api/cron/notifications/route.ts`
2. Transaction used: `grep "\\$transaction" src/app/api/cron/notifications/route.ts` returns match
3. Flag update uses tx: `grep "tx\\.insurancePolicy" src/app/api/cron/notifications/route.ts` returns match
  </verify>
  <done>
- Insurance expiry notifications wrapped in Prisma transaction
- Flag update uses transaction client (tx)
- Failures logged but don't break cron loop
- alertsSent only incremented on success
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error handling for transaction edge cases</name>
  <files>src/app/api/cron/notifications/route.ts</files>
  <action>
Verify the error handling covers edge cases:

1. **Check the try/catch wraps the transaction** (should already be done in Task 1)

2. **Add explicit logging for which alert tier failed:**
```typescript
} catch (error) {
  const alertTier = updateData.alert90Sent ? "90-day" :
                    updateData.alert60Sent ? "60-day" :
                    updateData.alert30Sent ? "30-day" : "unknown";
  console.error(
    `Failed to send ${alertTier} insurance expiry alert for policy ${policy.id}:`,
    error
  );
}
```

3. **Ensure the loop continues after failure** (should already have `continue` or just let loop iterate)

4. **No changes needed to notifyInsuranceExpiry()** - it already uses createNotification() which handles its own database operations. The transaction here is specifically for the flag update atomicity.

This task is primarily verification that Task 1 was implemented correctly with proper error logging.
  </action>
  <verify>
1. Error log includes alert tier: `grep "alertTier\|90-day\|60-day\|30-day" src/app/api/cron/notifications/route.ts` returns match
2. Build succeeds: `npm run build`
  </verify>
  <done>
- Error logging includes which alert tier (90/60/30 day) failed
- Loop continues after individual policy failures
- Build passes
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. Build succeeds: `npm run build`
2. Transaction pattern in place: grep for `$transaction` in notifications route
3. Transaction client used for flag update: grep for `tx.insurancePolicy`
4. Error logging improved with tier identification
</verification>

<success_criteria>
- Insurance expiry alert + flag update wrapped in db.$transaction()
- Flag update uses tx client (not db client)
- Transaction failure logs error but continues cron loop
- Log message identifies which alert tier (90/60/30) failed
- Build passes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-notification-targeting/06-02-SUMMARY.md`
</output>
