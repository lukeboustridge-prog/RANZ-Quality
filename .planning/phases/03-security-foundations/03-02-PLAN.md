---
phase: 03-security-foundations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/audit-log.ts
autonomous: true

must_haves:
  truths:
    - "Audit log entries include SHA-256 hash computed from entry data"
    - "Each audit log entry links to previous entry via previousHash field"
    - "Hash chain verification can detect tampering or deletion"
  artifacts:
    - path: "src/lib/audit-log.ts"
      provides: "Tamper-evident audit logging utility"
      exports: ["createAuditLog", "verifyAuditChain", "logInsuranceMutation", "logDocumentMutation", "logMemberMutation"]
      min_lines: 100
  key_links:
    - from: "src/lib/audit-log.ts"
      to: "@prisma/client"
      via: "AuditAction enum import"
      pattern: "import.*AuditAction.*from.*@prisma/client"
    - from: "src/lib/audit-log.ts"
      to: "src/lib/db.ts"
      via: "Prisma client for database writes"
      pattern: "import.*db.*from.*db"
---

<objective>
Create the core audit logging utility with SHA-256 hash chain for tamper-evident mutation tracking.

Purpose: Enable immutable audit trail where each log entry cryptographically links to the previous, making unauthorized modifications mathematically detectable.
Output: audit-log.ts with createAuditLog(), verifyAuditChain(), and convenience wrappers for insurance/document/member mutations.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-foundations/03-RESEARCH.md

@prisma/schema.prisma (AuditLog model, AuditAction enum)
@src/lib/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit-log.ts with hash chain implementation</name>
  <files>src/lib/audit-log.ts</files>
  <action>
Create src/lib/audit-log.ts with:

```typescript
import { db } from "./db";
import { auth } from "@clerk/nextjs/server";
import { AuditAction } from "@prisma/client";
import crypto from "crypto";

interface AuditLogInput {
  action: AuditAction;
  resourceType: string;
  resourceId: string;
  previousState?: Record<string, unknown> | null;
  newState?: Record<string, unknown> | null;
  metadata?: Record<string, unknown> | null;
  ipAddress?: string;
  userAgent?: string;
}

/**
 * Creates tamper-evident audit log entry with SHA-256 hash chain.
 *
 * Hash Chain Pattern:
 * - Each entry computes SHA-256 of: eventId + actor + action + resource + timestamp + previousHash + states
 * - previousHash links to most recent entry, creating mathematical dependency
 * - Tampering with any entry breaks the chain for all subsequent entries
 */
export async function createAuditLog(input: AuditLogInput): Promise<void> {
  try {
    // Get actor information (userId from Clerk, or system for cron jobs)
    let actorId = "system:unknown";
    let actorEmail = "system@ranz.org.nz";
    let actorRole = "system";

    try {
      const authResult = await auth();
      if (authResult.userId) {
        actorId = authResult.userId;
        // In production, fetch email from Clerk. For now, use placeholder.
        actorEmail = `user-${authResult.userId}@ranz.org.nz`;
        actorRole = "org:member";
      }
    } catch {
      // Auth may fail in cron/webhook contexts - use system identity
      actorId = "system:cron";
    }

    // Fetch most recent audit log entry to chain to
    const previousEntry = await db.auditLog.findFirst({
      orderBy: { id: "desc" },
      select: { hash: true },
    });

    const eventId = crypto.randomUUID();
    const timestamp = new Date();
    const previousHash = previousEntry?.hash || null;

    // Compute SHA-256 hash linking this entry to previous
    // CRITICAL: Use consistent serialization (pipe-delimited, ISO dates)
    const hashInput = [
      eventId,
      actorId,
      input.action,
      input.resourceType,
      input.resourceId,
      timestamp.toISOString(),
      previousHash || "genesis",
      JSON.stringify(input.previousState || null),
      JSON.stringify(input.newState || null),
      JSON.stringify(input.metadata || null),
    ].join("|");

    const hash = crypto.createHash("sha256").update(hashInput).digest("hex");

    // Write audit log entry (immutable - never UPDATE or DELETE)
    await db.auditLog.create({
      data: {
        eventId,
        actorId,
        actorEmail,
        actorRole,
        ipAddress: input.ipAddress || null,
        userAgent: input.userAgent || null,
        action: input.action,
        resourceType: input.resourceType,
        resourceId: input.resourceId,
        previousState: input.previousState || undefined,
        newState: input.newState || undefined,
        metadata: input.metadata || undefined,
        hash,
        previousHash,
        timestamp,
      },
    });
  } catch (error) {
    // Log but don't throw - audit logging failure shouldn't break application
    console.error("Failed to create audit log:", error);
  }
}

/**
 * Verifies integrity of entire audit log hash chain.
 *
 * Verification Process:
 * 1. Fetch all entries in chronological order
 * 2. For each entry, verify previousHash matches actual previous entry's hash
 * 3. Recompute hash from entry data and compare to stored hash
 * 4. Any mismatch indicates tampering
 */
export async function verifyAuditChain(): Promise<{
  valid: boolean;
  brokenAt?: bigint;
  message?: string;
  totalEntries?: number;
}> {
  try {
    const entries = await db.auditLog.findMany({
      orderBy: { id: "asc" },
    });

    if (entries.length === 0) {
      return { valid: true, totalEntries: 0 };
    }

    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const expectedPreviousHash = i > 0 ? entries[i - 1].hash : null;

      // Check chain linkage
      if (entry.previousHash !== expectedPreviousHash) {
        return {
          valid: false,
          brokenAt: entry.id,
          message: `Hash chain broken at entry ${entry.id}: expected previousHash ${expectedPreviousHash}, got ${entry.previousHash}`,
          totalEntries: entries.length,
        };
      }

      // Recompute hash to detect tampering
      const hashInput = [
        entry.eventId,
        entry.actorId,
        entry.action,
        entry.resourceType,
        entry.resourceId,
        entry.timestamp.toISOString(),
        entry.previousHash || "genesis",
        JSON.stringify(entry.previousState),
        JSON.stringify(entry.newState),
        JSON.stringify(entry.metadata),
      ].join("|");

      const recomputedHash = crypto
        .createHash("sha256")
        .update(hashInput)
        .digest("hex");

      if (entry.hash !== recomputedHash) {
        return {
          valid: false,
          brokenAt: entry.id,
          message: `Entry ${entry.id} tampered - stored hash doesn't match recomputed hash`,
          totalEntries: entries.length,
        };
      }
    }

    return { valid: true, totalEntries: entries.length };
  } catch (error) {
    console.error("Failed to verify audit chain:", error);
    return {
      valid: false,
      message: `Verification failed: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Convenience wrapper for logging insurance policy mutations.
 */
export async function logInsuranceMutation(
  action: "CREATE" | "UPDATE" | "DELETE",
  policyId: string,
  previousState: Record<string, unknown> | null,
  newState: Record<string, unknown> | null,
  metadata?: { organizationId: string; certificateUploaded?: boolean }
): Promise<void> {
  await createAuditLog({
    action,
    resourceType: "InsurancePolicy",
    resourceId: policyId,
    previousState,
    newState,
    metadata,
  });
}

/**
 * Convenience wrapper for logging document mutations.
 */
export async function logDocumentMutation(
  action: "CREATE" | "UPDATE" | "DELETE" | "APPROVE" | "REJECT",
  documentId: string,
  previousState: Record<string, unknown> | null,
  newState: Record<string, unknown> | null,
  metadata?: { organizationId?: string; versionId?: string }
): Promise<void> {
  await createAuditLog({
    action,
    resourceType: "Document",
    resourceId: documentId,
    previousState,
    newState,
    metadata,
  });
}

/**
 * Convenience wrapper for logging member mutations.
 */
export async function logMemberMutation(
  action: "CREATE" | "UPDATE" | "DELETE" | "VERIFY",
  memberId: string,
  previousState: Record<string, unknown> | null,
  newState: Record<string, unknown> | null,
  metadata?: { organizationId?: string; lbpVerification?: boolean }
): Promise<void> {
  await createAuditLog({
    action,
    resourceType: "OrganizationMember",
    resourceId: memberId,
    previousState,
    newState,
    metadata,
  });
}
```

Key implementation details:
- Uses Node.js built-in crypto module for SHA-256 (no dependencies)
- Hash input uses pipe-delimited string with ISO date format for consistency
- Silently catches errors to not break application (but logs them)
- First entry has previousHash=null with "genesis" in hash calculation
- Convenience wrappers use proper AuditAction enum values
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors in audit-log.ts.
Verify file exports: createAuditLog, verifyAuditChain, logInsuranceMutation, logDocumentMutation, logMemberMutation.
  </verify>
  <done>
audit-log.ts exists with hash chain implementation. All exports available. Compiles successfully.
  </done>
</task>

</tasks>

<verification>
After task completion:
1. `npx tsc --noEmit` passes for audit-log.ts
2. File exports all required functions
3. Hash computation uses SHA-256 with consistent pipe-delimited format
4. previousHash links to previous entry (or null for first entry)
</verification>

<success_criteria>
- src/lib/audit-log.ts created with full implementation
- createAuditLog() computes SHA-256 hash and links to previous entry
- verifyAuditChain() validates chain integrity by recomputing hashes
- Convenience wrappers exist for insurance, document, and member mutations
- Module compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-foundations/03-02-SUMMARY.md`
</output>
