---
phase: 04-public-api-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - next.config.ts
  - src/app/api/documents/route.ts
  - src/app/api/documents/[id]/versions/route.ts
  - src/app/api/insurance/route.ts
  - src/app/api/insurance/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "File upload exceeding 50MB returns 413 error"
    - "413 error occurs before R2 upload is attempted"
    - "413 error occurs before database write is attempted"
    - "Error message includes file size and limit"
    - "Valid files under 50MB still upload successfully"
  artifacts:
    - path: "next.config.ts"
      provides: "Global body size limit configuration"
      contains: "bodySizeLimit"
    - path: "src/app/api/documents/route.ts"
      provides: "Size validation in document upload"
      contains: "MAX_FILE_SIZE_BYTES"
    - path: "src/app/api/documents/[id]/versions/route.ts"
      provides: "Size validation in version upload"
      contains: "MAX_FILE_SIZE_BYTES"
    - path: "src/app/api/insurance/route.ts"
      provides: "Size validation in insurance upload"
      contains: "MAX_FILE_SIZE_BYTES"
    - path: "src/app/api/insurance/[id]/route.ts"
      provides: "Size validation in insurance update"
      contains: "MAX_FILE_SIZE_BYTES"
  key_links:
    - from: "src/app/api/documents/route.ts"
      to: "src/types/index.ts"
      via: "import MAX_FILE_SIZE constants"
      pattern: "import.*MAX_FILE_SIZE"
---

<objective>
Add file upload size validation to prevent storage quota exhaustion attacks.

Purpose: Authenticated users could upload extremely large files to exhaust Cloudflare R2 storage quota, causing service denial. By validating size at 50MB before any processing, we fail fast and protect resources.

Output: All file upload endpoints validate size before database writes or R2 uploads, returning 413 for oversized files.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-public-api-hardening/04-RESEARCH.md
@next.config.ts
@src/app/api/documents/route.ts
@src/app/api/documents/[id]/versions/route.ts
@src/app/api/insurance/route.ts
@src/app/api/insurance/[id]/route.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Next.js global body size limit</name>
  <files>next.config.ts</files>
  <action>
Update next.config.ts to set a global body size limit of 50MB.

This provides defense-in-depth at the framework level, rejecting oversized requests before they even reach our handlers.

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // Set maximum body size for API routes to 50MB
  // This provides first-line defense against oversized uploads
  experimental: {
    serverActions: {
      bodySizeLimit: '50mb',
    },
  },
};

export default nextConfig;
```

Note: While this config is for serverActions, it also affects API routes in the App Router. The handler-level validation in subsequent tasks provides explicit control and better error messages.
  </action>
  <verify>Check that next.config.ts has the new configuration:
```bash
grep -A3 "bodySizeLimit" next.config.ts
```
Should show the bodySizeLimit: '50mb' configuration.</verify>
  <done>Next.js configured with 50MB global body size limit</done>
</task>

<task type="auto">
  <name>Task 2: Add size validation to document upload endpoints</name>
  <files>src/app/api/documents/route.ts, src/app/api/documents/[id]/versions/route.ts</files>
  <action>
Update both document upload endpoints to validate file size before processing.

**For src/app/api/documents/route.ts:**

1. Add import for MAX_FILE_SIZE constants at the top:
```typescript
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB } from "@/types";
```

2. After getting the file from formData, add size validation BEFORE the existing empty file check:
```typescript
const file = formData.get("file") as File | null;

// FAIL-FAST: Validate file size before any processing
if (file && file.size > MAX_FILE_SIZE_BYTES) {
  return NextResponse.json(
    {
      error: `File exceeds maximum size of ${MAX_FILE_SIZE_MB}MB`,
      details: {
        maxSizeBytes: MAX_FILE_SIZE_BYTES,
        maxSizeMB: MAX_FILE_SIZE_MB,
        actualSizeBytes: file.size,
        actualSizeMB: Math.round(file.size / 1024 / 1024 * 100) / 100,
      }
    },
    { status: 413 }
  );
}

if (!file || file.size === 0) {
  return NextResponse.json({ error: "File is required" }, { status: 400 });
}
```

**For src/app/api/documents/[id]/versions/route.ts:**

1. Add the same import:
```typescript
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB } from "@/types";
```

2. Add the same size validation after getting file from formData, before the empty file check:
```typescript
const file = formData.get("file") as File | null;
const changeNotes = formData.get("changeNotes") as string;
const isMajorVersion = formData.get("isMajorVersion") === "true";

// FAIL-FAST: Validate file size before any processing
if (file && file.size > MAX_FILE_SIZE_BYTES) {
  return NextResponse.json(
    {
      error: `File exceeds maximum size of ${MAX_FILE_SIZE_MB}MB`,
      details: {
        maxSizeBytes: MAX_FILE_SIZE_BYTES,
        maxSizeMB: MAX_FILE_SIZE_MB,
        actualSizeBytes: file.size,
        actualSizeMB: Math.round(file.size / 1024 / 1024 * 100) / 100,
      }
    },
    { status: 413 }
  );
}

if (!file || file.size === 0) {
  return NextResponse.json({ error: "File is required" }, { status: 400 });
}
```

The order is critical:
1. Parse formData (required to access file)
2. Check file size (fail fast with 413 if too large)
3. Check file exists (400 if missing)
4. Only then proceed with Buffer conversion, hash generation, R2 upload, database write
  </action>
  <verify>Check that both files have the size validation:
```bash
grep -n "MAX_FILE_SIZE_BYTES" src/app/api/documents/route.ts src/app/api/documents/\[id\]/versions/route.ts
```
Should show matches in both files.</verify>
  <done>Document upload endpoints validate file size before processing, returning 413 for oversized files</done>
</task>

<task type="auto">
  <name>Task 3: Add size validation to insurance upload endpoints</name>
  <files>src/app/api/insurance/route.ts, src/app/api/insurance/[id]/route.ts</files>
  <action>
Update both insurance upload endpoints to validate certificate file size before processing.

**For src/app/api/insurance/route.ts:**

1. Add import for MAX_FILE_SIZE constants at the top:
```typescript
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB } from "@/types";
```

2. After getting the certificate file from formData (around line 92), add size validation:
```typescript
const file = formData.get("certificate") as File | null;

// FAIL-FAST: Validate certificate file size before any processing
if (file && file.size > MAX_FILE_SIZE_BYTES) {
  return NextResponse.json(
    {
      error: `Certificate file exceeds maximum size of ${MAX_FILE_SIZE_MB}MB`,
      details: {
        maxSizeBytes: MAX_FILE_SIZE_BYTES,
        maxSizeMB: MAX_FILE_SIZE_MB,
        actualSizeBytes: file.size,
        actualSizeMB: Math.round(file.size / 1024 / 1024 * 100) / 100,
      }
    },
    { status: 413 }
  );
}

let certificateKey: string | null = null;

if (file && file.size > 0) {
  const buffer = Buffer.from(await file.arrayBuffer());
  // ... rest of upload logic
}
```

**For src/app/api/insurance/[id]/route.ts:**

1. Add import for MAX_FILE_SIZE constants:
```typescript
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB } from "@/types";
```

2. In the PUT handler, after getting the file (around line 117), add size validation:
```typescript
const file = formData.get("certificate") as File | null;

// FAIL-FAST: Validate certificate file size before any processing
if (file && file.size > MAX_FILE_SIZE_BYTES) {
  return NextResponse.json(
    {
      error: `Certificate file exceeds maximum size of ${MAX_FILE_SIZE_MB}MB`,
      details: {
        maxSizeBytes: MAX_FILE_SIZE_BYTES,
        maxSizeMB: MAX_FILE_SIZE_MB,
        actualSizeBytes: file.size,
        actualSizeMB: Math.round(file.size / 1024 / 1024 * 100) / 100,
      }
    },
    { status: 413 }
  );
}

let certificateKey = existingPolicy.certificateKey;

if (file && file.size > 0) {
  // ... rest of upload logic
}
```

Note: Insurance certificate uploads are optional (unlike document uploads which require a file), so we only validate size if a file is provided.
  </action>
  <verify>Check that both insurance files have the size validation:
```bash
grep -n "MAX_FILE_SIZE_BYTES" src/app/api/insurance/route.ts src/app/api/insurance/\[id\]/route.ts
```
Should show matches in both files.</verify>
  <done>Insurance upload endpoints validate certificate file size before processing, returning 413 for oversized files</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Next.js config has body size limit:
```bash
grep "bodySizeLimit" next.config.ts
```

2. All upload endpoints import MAX_FILE_SIZE:
```bash
grep -l "MAX_FILE_SIZE_BYTES" src/app/api/documents/route.ts src/app/api/documents/\[id\]/versions/route.ts src/app/api/insurance/route.ts src/app/api/insurance/\[id\]/route.ts
```
Should list all 4 files.

3. All upload endpoints have 413 status code:
```bash
grep -c "status: 413" src/app/api/documents/route.ts src/app/api/documents/\[id\]/versions/route.ts src/app/api/insurance/route.ts src/app/api/insurance/\[id\]/route.ts
```

4. TypeScript compiles:
```bash
npx tsc --noEmit --skipLibCheck 2>&1 | head -20
```
</verification>

<success_criteria>
- [ ] next.config.ts has experimental.serverActions.bodySizeLimit set to '50mb'
- [ ] src/app/api/documents/route.ts validates file size and returns 413 if >50MB
- [ ] src/app/api/documents/[id]/versions/route.ts validates file size and returns 413 if >50MB
- [ ] src/app/api/insurance/route.ts validates certificate size and returns 413 if >50MB
- [ ] src/app/api/insurance/[id]/route.ts validates certificate size and returns 413 if >50MB
- [ ] All 413 responses include error message with max size and actual size details
- [ ] Size check occurs BEFORE Buffer.from(file.arrayBuffer()) in all endpoints
- [ ] Size check occurs BEFORE any database writes in all endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/04-public-api-hardening/04-03-SUMMARY.md`
</output>
